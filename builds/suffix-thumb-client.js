const e=/^.([0-9]+)/,t=function(t,r,n){if(r.exceptions.hasOwnProperty(t))return n&&console.log("exception, ",t,r.exceptions[t]),function(t,r){let n=r.exceptions[t],l=n.match(e);if(null===l)return r.exceptions[t];let o=Number(l[1])||0;return t.substr(0,o)+n.replace(e,"")}(t,r);let l=r.rules;r.reversed&&(l=r.rev),l=function(e,t={}){let r=t[e[e.length-1]]||[];return t[""]&&(r=r.concat(t[""])),r}(t,l);for(let e=0;e<l.length;e+=1){let r=l[e][0];if(t.endsWith(r)){n&&console.log("rule, ",l[e]);let o=new RegExp(r+"$");return t.replace(o,l[e][1])}}return n&&console.log(" x - "+t),t},r=function(e,t={}){let r={},n={};return e=e.filter((e=>void 0!==r[e[0]]?(t.debug&&(console.warn("Duplicate left side:"),console.log("  1.",[e[0],r[e[0]]]),console.log("  2.",e)),!1):void 0!==n[e[1]]?(t.debug&&(console.warn("Duplicate right side:"),console.log("  1.",[n[e[1]],e[1]]),console.log("  2.",e)),!1===t.inverse):(r[e[0]]=e[1],n[e[1]]=e[0],!0)))},n=function(e){let t={};return e.forEach((e=>{let r=e[0]||"",n=r[r.length-1]||"";t[n]=t[n]||[],t[n].push(e)})),t},l=/^([0-9]+)/,o=function(e){const t=/\|/;return e.split(/,/).map((e=>{let r=e.split(t);return function(e="",t=""){let r=(t=String(t)).match(l);if(null===r)return[e,t];let n=Number(r[1])||0,o=e.substring(0,n);return[e,o+t.replace(l,"")]}(r[0],r[1])}))},s=function(e={}){return(e=Object.assign({},e)).rules=o(e.rules),e.rules=n(e.rules),e.rev&&(e.rev=o(e.rev),e.rev=n(e.rev)),e.exceptions=o(e.exceptions),e.exceptions=e.exceptions.reduce(((e,t)=>(e[t[0]]=t[1],e)),{}),e},u=function(e){let{rules:t,exceptions:r,rev:n}=e;var l;return l=r,r=Object.entries(l).reduce(((e,t)=>(e[t[1]]=t[0],e)),{}),{reversed:!Boolean(e.reversed),rules:t,exceptions:r,rev:n}},i=function(e,t){return t[e[e.length-1]]||[]},c=function(e,t,r){const n="Left",l="Right";if(t.exceptions.hasOwnProperty(e))return n;let o=Object.entries(t.exceptions);for(let t=0;t<o.length;t+=1)if(o[t][1]===e)return l;let s=i(e,t.rules);for(let t=0;t<s.length;t+=1)if(e.endsWith(s[t][0]))return n;s=i(e,t.rev);for(let t=0;t<s.length;t+=1)if(e.endsWith(s[t][0]))return l;s=i(e,t.rules);for(let t=0;t<s.length;t+=1)if(e.endsWith(s[t][1]))return l;s=i(e,t.rev);for(let t=0;t<s.length;t+=1)if(e.endsWith(s[t][1]))return n;return null};export{c as classify,t as convert,u as reverse,s as uncompress,r as validate};
